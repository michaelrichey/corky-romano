---
title: "Eloquent Javascript Notes: Chapter 4"
date: 2020-05-06
layout: blog-layout
category: javascript
---

Welcome to the notes for [Chapter 4: Data Structures: Objects and Arrays](https://eloquentjavascript.net/04_data.html). Let's read, shalln't we?

## Michael's Notes

### Concepts I Don't Understand

**Item**

asdf

**Item**

asdf

### New Vocabulary

**Properties**

Something that a value has. Like _length_ is a value of a string. Every value has properties of some kind, expect null and undefined. Dot notation and bracket notation are the ways to access value properties. With dot notation, the name after the dot is the name of the property. In bracket notation, the name in brackets is evaluated to get the property.

Also, objects have properties. The "item" of an object is called a property.

**Methods**

Properties that contain functions.

**`"propertyName" in objectName`**

The `in` keyword can be used to tell you if a property existsin within a certain object.

**`of` keyword**

A `for...of` loop is shorthand for the common for loop that requires you to set a counter. This is a simplification:

````
array1 = [a, b, c]

for (const element of array1) {
  console.log(element);
}
```

From this, you'll get a, b, and c logged to the console individually. It's like a forEach or an .each method in ruby. You add the array you want to iterate over after the keyword `of`. Then you give a name to the items in the array so you can use it in the code block. In this one, we used element.

**`shift` and `unshift` methods**

These methods add and remove things to the BEGINNING of an array.

`shift` removes the first item from an array.

`unshift` adds an item to the front of an array.

**`indexOf` method**

The `indexOf` method is used to find the index of a certain value in an array. You can also use `lastIndexOf` to start at the end of the array instead of the beginning.

**Immutable Objects**

- strings
- booleans
- integers

**`trim` method**

Removes whitespace from beginning and end of strings.

**`padStart` method**

Takes a string, then add pad character and numbers of pad character as arguments. It adds the number of pad characters to the beginning of the string.

**`repeat` method**

`console.log("LA".repeat(3));`

Add to a string and add number of times to repeat as argument. It's like doing `"string" * 3` in Ruby, which you can't do in JS. I needed this in an exercism!

**three-dot `spread` operator**

You can use three dots before an argument name (`...numbers`), which will take all the items in the array `numbers` and spread them out with spaces. If this is passed in a function as an argument, they will each become individual arguments. This is a way you can pass in one argument and then use it to pass in as many as you want.

**The Math Object**

The `Math` object has its own methods. And you can use these methods to pass arguments, and it will perform various math functions on the number you passed in. You should pass in numbers, by the way.

`Math.random()` - give a random number, between 0 and 1
`Math.round()` - round the number up
`Math.ceil()` - round number up
`Math.floor()` - round number down
`Math.pow()` - get power of. Pass in number you want to get power of, and also to the power of what number
`Math.sqrt()` - get the square root of a number

**Destructuring**

In a normal variable assignment, you use the `=` operator to assign a value to binding. You can even assign a whole array to it.

But in destructuring, the left side of the variable assignment is an array. Each item in the array, takes on an assignment equal to the array on the left.

This is a way to batch-assign arrays.

Or it can be another variable on the right side, and the array will each through and assign itself whatever it can find in the variable.

Seems kind of messy to me. Is this a good way to assign variables?

Learned about this from MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

**JSON*

Javascript Object Notation. This is data store in objects, which is stored in a JSON file. You can use this to send your data to other places, or use it easily. Like a data file in yaml (I think).

### Sections That Were Written Not So Well

**Array loops section**

> There is a simpler way to write such loops in modern JavaScript.

> for (let entry of JOURNAL) {
>   console.log(`${entry.events.length} events.`);
> }

> When a for loop looks like this, with the word of after a variable definition, it will loop over the elements of the value given after of. This works not only for arrays but also for strings and some other data structures. We’ll discuss how it works in Chapter 6.
asdf

This whole section reads poorly: "it will loop over the elements of the value given after of." Not well communicated. And the example given does nothing to clear it up.

Compare to example on MDN: 
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of

Within five minutes I knew how this loop worked.

**Everything about the weresquirrel**

It was a good idea to get a story mixed in to make a concept more sticky. But that good decision was squandered by the overcomplicated math. We're dealing with dense concepts already, so a story can help those dense cocepts stick. But the javascript example embedded in the story indid the good work of the story itself.

In general, the javascript exeamples in the book are a hair too complex. Unlike MDN that uses overly simple examples to illustrate a new concept, it seems the book expects you to already know JS, because it's going to explain the concepts to you in ways that might bend your mind a little further. It's extra distraction in a space where you're trying to concentrate.

**Destructuring**

Not clear what the concept is. I had to learn about it from MDN. To be fair, it's not entirely clear after reading MDN, so it's a tough concept, but the book could have used better examples.

## Random questions

- Should I refresh calculus, algebra, or other math concepts?

<script>

// The sum of a range

let range = function (start, end, step=1) {
    arr = []
    if (start > end && Math.sign(step) == -1) {
        while (start >= end) {
            arr.push(start)
            start = start + step
        }
    } else if (start < end && Math.sign(step) == 1) {
        while (start <= end) {
            arr.push(start)
            start = start + step
            }
    } else {
        console.log('it broke')
    }

    return arr
}

let sum = function (array) {
    result = null
    for (const element of array) {
        result = result + element
    }
    return result
}

console.log(range(1, 10));
// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(sum(range(1, 10)));
// → 55

// bonus
console.log(range(5, 2, -1));
// → [5, 4, 3, 2]

console.log(range(1, 10, 2));
console.log(range(1, 20, 3));
console.log(range(20, 5, 3));
console.log(range(20, 5, -3));

// Reversing an array

let reverseArray = function (array) {
    newarr = []
    for (const element of array) {
        newarr.unshift(element)
    }
    return newarr
}

let reverseArrayInPlace = function (array) {
    newarr = []
    for (const element of array) {
        newarr.unshift(element)
    }
    index = 0
    newarr.forEach(function (e) {
        array[index] = e
        index++
    })
}

superarray = [1, 2, 3, 4, 5]

reverseArrayInPlace(superarray)
console.log('your test, master: ' + superarray)

console.log(reverseArray(["A", "B", "C"]));
// → ["C", "B", "A"];
console.log(reverseArray(["apple", "banana", "carrot", "donkey", "edmund"]));
 let arrayValue = [1, 2, 3, 4, 5];
 reverseArrayInPlace(arrayValue);
 console.log('final: '+ arrayValue);
// → [5, 4, 3, 2, 1]

// A list

let arrayToList = function (array) {
    let list = {}
    list.value = null
    list.next = null
    array.forEach(function (e) {
        if (!list.value) {
            list.value = e
        } else if (list.value) {
            list.next = e
        }
    })
    return list
}

// console.log(arrayToList([10, 20, 30, 40]));
// → {value: 10, rest: {value: 20, rest: null}}
// console.log(listToArray(arrayToList([10, 20, 30])));
// → [10, 20, 30]
// console.log(prepend(10, prepend(20, null)));
// → {value: 10, rest: {value: 20, rest: null}}
// console.log(nth(arrayToList([10, 20, 30]), 1));
// → 20

// Practice mutability

let object1 = {value: 10}
let object2 = object1
let object3 = {value: 10}

console.log(object1 == object2)
console.log(object1 == object3)
console.log(object1.value, object2.value)
object1.value = 15
console.log(object1.value, object2.value)

const score = {visitors: 0, home: 0}
console.log(score.visitors)
score.visitors = 2
score.home = 4
console.log(score.visitors)
console.log(score.home)

let score1 = {visitors: 0, home: 0}
score1 = {visitors: 7, home: 19}
console.log(score1.visitors)
console.log(score1.home)


// Practice destructuring

const people = [
    {
        name: 'Joe Lambert',
        job: 'architect',
        mform: 'werewolf',
        vehicle: 'snowmobile'
    },
        {
        name: 'Susan Fenwick',
        job: 'hedge fund manager',
        mform: 'gil person',
        vehicle: 'hoverboard'
    },
        {
        name: 'Harmony Vanderbilt',
        job: 'veternarian',
        mform: 'gargoyle',
        vehicle: 'dirtbike'
    }
]


let message = () => {
    people.forEach(function (person) {
        let {
        name,
        job,
        mform,
        vehicle
        } = person   
        console.log(
            `${name} is an ordinary ${job} by day, but at night transforms into a hideous ${mform} and tears through the city on a ${vehicle}.`
        )

    })
}

message()

// Practice destructuring 2

const person = {firstName: 'Hamcow'}
const {firstName} = person
console.log(firstName)

// Practice destructuring 3

const sanriochar = [
    {
        name: "Keroppi",
        home: "Donut Pond",
    },
    {
        name: "Tuxedo Sam",
        home: "Antarctica",
    },
    {
        name: "Pompom Purin",
        home: "France",
    }
]

let tell = () => {
    for({name, home} of sanriochar) {
        console.log(`${name} lives in ${home}.`)
    }
}

tell()




</script>